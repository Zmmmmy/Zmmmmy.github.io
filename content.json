{"meta":{"title":"芝麻盐的博客","subtitle":"","description":"","author":"Zmy","url":"https://Zmmmmy.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-07-02T16:59:11.663Z","updated":"2020-07-02T16:59:11.663Z","comments":true,"path":"404.html","permalink":"https://zmmmmy.github.io/404","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于这个博客","date":"2020-07-03T02:57:26.444Z","updated":"2020-07-03T02:57:26.444Z","comments":true,"path":"about/index.html","permalink":"https://zmmmmy.github.io/about/","excerpt":"","text":"这是一个专属于芝麻盐的博客这个小破站就是我芝麻盐专属的一亩三分地 为啥会搭建一个博客呢？ 初衷是为了整理学习笔记，因为我的学习笔记整的实在是是的太太太乱了！ 到底有多乱！ 看图………………………………………. 在一个就是保存的问题了，万一电脑有个三长两短，资料全没了！我这小心脏可受不了奥。 开始想的是把笔记全都上传到GitHub上，但是每次都要拉取,上传的太麻烦了啊！ 所以就有了一个搭建博客的想法！ 然后就整了一个 没想到这玩意越整越好看 于是又有了一个想法 …………………………………… 太晚了！明天写！"},{"title":"所有标签","date":"2020-07-02T16:59:11.771Z","updated":"2020-07-02T16:59:11.771Z","comments":true,"path":"tags/index.html","permalink":"https://zmmmmy.github.io/tags/","excerpt":"","text":""},{"title":"所有分类","date":"2020-07-02T16:59:11.770Z","updated":"2020-07-02T16:59:11.770Z","comments":true,"path":"categories/index.html","permalink":"https://zmmmmy.github.io/categories/","excerpt":"","text":""},{"title":"留言板","date":"2020-07-02T16:59:11.770Z","updated":"2020-07-02T16:59:11.770Z","comments":true,"path":"comments/index.html","permalink":"https://zmmmmy.github.io/comments/","excerpt":"","text":"这是一个还没有整好的留言板"}],"posts":[{"title":"Java8新特性","slug":"Java8新特性/Java8新特性","date":"2020-07-03T03:01:01.000Z","updated":"2020-07-03T03:22:17.964Z","comments":true,"path":"posts/397c083a.html","link":"","permalink":"https://zmmmmy.github.io/posts/397c083a","excerpt":"这是一篇关于Java8的笔记","text":"这是一篇关于Java8的笔记 Java8新特性一、Lambda表达式1.简介​ Java8引入了一个新的操作符“一&gt;”该操作符称为箭头操作符或lambda操作符，Lambda表达式拆分为两部分 左侧：Lambda 表达式的参数列表 右侧：Lambda 表达式中所需要执行的功能 2.语法格式语法格式一：无参数，无返回值 12345678910111213@Test public void test1()&#123; Runnable r = new Runnable() &#123; @Override public void run() &#123; System.out.println(\"Hello World\"); &#125; &#125;; r.run(); System.out.println(\"-----Lambda-----\"); Runnable r1 = () -&gt; System.out.println(\"Hello World\"); r1.run(); &#125; 语法格式二：有一个参数，无返回值 12345@Testpublic void test2()&#123; Consumer&lt;String&gt; con = (x) -&gt; System.out.println(x); con.accept(\"测试\");&#125; 语法格式三：有一个参数，小括号可以不写 12345@Testpublic void test3()&#123; Consumer&lt;String&gt; con = x -&gt; System.out.println(x); con.accept(\"测试\"); &#125; 语法格式三：有多个参数，并且Lambda体中有多条语句，用大括号 1234567@Testpublic void test4()&#123; Comparator&lt;Integer&gt; com = (x,y) -&gt; &#123; System.out.println(\"函数式接口测试\"); return Integer.compare(x,y); &#125;;&#125; 类型推断，lambda参数列表并没有给出具体的参数类型，而是靠上下文推断出来的类型 3、函数式接口Lambda表达式需要函数式接口支持 函数式接口可以使用 @FunctionalInterface 注解标注 1.创建一个函数式接口 1234@FunctionalInterfacepublic interface LambdaTest &#123; Integer getInteger(Integer num);&#125; 2.测试方法 12345678@Testpublic void test5()&#123; Integer sum = sum(10, (x) -&gt; x * x); System.out.println(sum);&#125;public Integer sum(Integer a, com.zmy.LambdaTest lambdaTest)&#123; return lambdaTest.getInteger(a);&#125; 4、四大内置函数式核心接口1.Consumer：消费型接口（无返回方法）123public interface Consumer&lt;T&gt; &#123; void accept(T t);&#125; 例子：12345678910@Testpublic void test1()&#123; show(25,(x) -&gt; &#123; System.out.println(\"zmy今年\"+x+\"岁了\"); &#125;); &#125;public void show(int age , Consumer&lt;Integer&gt; consumer)&#123; consumer.accept(age); &#125; 2.Supplier：供给型接口（有返回方法）123public interface Supplier&lt;T&gt; &#123; T get();&#125; 例子：1234567891011121314151617@Testpublic void test2()&#123; List&lt;Integer&gt; list = getNumberList(10, () -&gt; (int) (Math.random() * 100)); for (Integer integer : list) &#123; System.out.println(integer); &#125; &#125;public List&lt;Integer&gt; getNumberList(int num,Supplier&lt;Integer&gt; sup)&#123; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; num; i++) &#123; Integer integer = sup.get(); arrayList.add(integer); &#125; return arrayList; &#125; 3.Function：函数型接口123public interface Function&lt;T, R&gt; &#123; R apply(T t);&#125; 例子：123456789@Testpublic void test3()&#123; String s = strHandler(\"\\t\\t\\t123456 \", (str) -&gt; str.trim()); System.out.println(s);&#125;public String strHandler(String str,Function&lt;String,String&gt; fun)&#123; return fun.apply(str);&#125; 4.Predicate：断言型接口123public interface Predicate&lt;T&gt; &#123; boolean test(T t);&#125; 例子：12345678910111213141516171819@Testpublic void test4()&#123; List&lt;String&gt; list = Arrays.asList(\"zmy\", \"jjl\", \"ym\"); List&lt;String&gt; str = filterStr(list, (s) -&gt; s.equals(\"zmy\")); for (String s : str) &#123; System.out.println(s); &#125;&#125;public List&lt;String&gt; filterStr(List&lt;String&gt; list,Predicate&lt;String&gt; pre)&#123; List&lt;String&gt; strList = new ArrayList&lt;&gt;(); for (String s : list) &#123; if (pre.test(s))&#123; strList.add(s); &#125; &#125; return strList;&#125; 5、方法引用和构造器引用1.方法引用1.简介方法引用：若Lambda体的内容已经实现了，我们可以使用方法引用(Lambda表达式的另一种体现) 2.格式有三种格式 对象 : : 实例方法名 类 : : 静态方法名 类 : : 实例方法名 3.注意 Lambda 体中调用方法的参数列表与返回值类型，要与函数式接口中方法的函数的参数列表和返回值类型保持一致 若Lambda参数列表中的第一个参数是调用者，而第二个参数是实例方法的参数时，可以使用ClassName : : method 3.例子1234567891011121314151617181920212223242526272829303132333435//对象::实例方法名@Testpublic void test()&#123; PrintStream out = System.out; Consumer&lt;String&gt; con = (x) -&gt; out.println(x); con.accept(\"111\"); PrintStream out1 = System.out; Consumer&lt;String&gt; con1 = out1::println; con1.accept(\"aaa\"); Consumer&lt;String&gt; con3 = System.out::println; con3.accept(\"bbb\");&#125;@Testpublic void test2()&#123; Person person = new Person(\"zmy\",25); Supplier&lt;String&gt; sup = () -&gt; person.getName(); String s = sup.get(); System.out.println(s); Supplier&lt;Integer&gt; sup2 = person::getAge; Integer integer = sup2.get(); System.out.println(integer);&#125;//类::静态方法@Testpublic void test3()&#123; Comparator&lt;Integer&gt; com = (x,y) -&gt; Integer.compare(x,y); Comparator&lt;Integer&gt; comparator = Integer::compare;&#125;//类::实例方法@Testpublic void test4()&#123; //参数x为实例方法的调用者y为参数 BiPredicate&lt;String,String&gt; bp = (x,y) -&gt; x.equals(y); BiPredicate&lt;String,String&gt; bp2 = String::equals;&#125; 2.构造器引用1.格式ClassName : : new 2.注意调用的构造器的参数列表要与函数式接口中的抽象方法的参数列表要一致 3.例子1234567//ClassName::new@Testpublic void test()&#123; Supplier&lt;Person&gt; supplier = Person::new; Person person = supplier.get(); System.out.println(person.getAge());&#125; 3.数组引用1234567@Testpublic void test1()&#123; Function&lt;Integer,String[]&gt; function = x -&gt; new String[x]; Function&lt;Integer,String[]&gt; function1 = String[]::new; String[] apply = function1.apply(10); System.out.println(apply.length);&#125; 二、Stream1.创建Stream的三个操作步骤 创建Stream 中间操作 终止操作 2.创建Stream 可以通过Collection系列集合提供的stream() 或 parallelStream() 可以通过Arrays中静态方法stream()获取数组流 可以通过Stream类中的静态方法 of() 创建无限流 12345678910111213141516171819202122@Testpublic void test1() &#123; //可以通过Collection系列集合提供的stream() 或 parallelStream() List&lt;String&gt; list = new ArrayList&lt;&gt;(); Stream&lt;String&gt; stream1 = list.stream(); //可以通过Arrays中静态方法stream()获取数组流 Person[] people = new Person[10]; Stream&lt;Person&gt; stream2 = Arrays.stream(people); //可以通过Stream类中的静态方法 of() Stream&lt;String&gt; stream3 = Stream.of(\"aaa\", \"bbb\", \"ccc\"); //创建无限流 //迭代 Stream&lt;Integer&gt; stream4 = Stream.iterate(0, (x) -&gt; x + 2); //stream4.forEach(System.out::println); stream4.limit(10L).forEach(System.out::println); Stream.generate(() -&gt; Math.random()) .limit(5) .forEach(System.out::println);&#125; 3.中间操作1.筛选与切片 filter-接收Lambda，从流中排除某些元素 limit-截断流，使元素不超过给定数量 skip(n)-跳过流，返回一个扔掉前n个元素的流。若流中元素不足n个，则返回一个空流，与limit(n)互补 distinct-筛选，通过流所产生的hashCode()和equals()去除重复元素 代码演示 创建一个集合： 123456789List&lt;Person&gt; people = Arrays.asList( new Person(\"zmy01\", 21, Person.Status.BUSY), new Person(\"zmy02\", 22, Person.Status.VOCATION), new Person(\"zmy07\", 23, Person.Status.BUSY), new Person(\"zmy08\", 23, Person.Status.FREE), new Person(\"zmy02\", 23, Person.Status.VOCATION), new Person(\"zmy03\", 23, Person.Status.BUSY), new Person(\"zmy04\", 24, Person.Status.FREE)); filter ：过滤1Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate); 12345678910111213//内部迭代：迭代操作有StreamAPI完成//外部迭代：自己实现迭代功能@Testpublic void test2() &#123; //中间操作：不会执行任何操作 Stream&lt;Person&gt; personStream = people.stream() .filter((e) -&gt; &#123; System.out.println(\"终止操作\"); return e.getAge() &gt; 23; &#125;); //终止操作：一次性执行全部内容 “惰性求值” personStream.forEach(System.out::println);&#125; limit ：显示特定个数1Stream&lt;T&gt; limit(long maxSize); 1234567891011@Testpublic void test3() &#123; people.stream() .filter(e -&gt; &#123; System.out.println(\"短路\"); return e.getAge() &gt; 20; &#125;) .limit(2) .forEach(System.out::println);&#125; skip：排除特定个数1Stream&lt;T&gt; skip(long n); 12345678910@Testpublic void test4() &#123; people.stream() .filter(e -&gt; &#123; return e.getAge() &gt; 20; &#125;) .skip(2) .forEach(System.out::println);&#125; distinct：去除重复元素，需要实现equals和hashCode1Stream&lt;T&gt; distinct(); 1234567@Testpublic void test5()&#123; people.stream() .filter(e-&gt;e.getAge()&gt;20) .distinct() .forEach(System.out::println);&#125; 2.映射 ​ map ：接收Lambda，将元素转化成其他格式或提取，接收一个函数作为参数，该函数会被应用到每一个元素上，并将其映射成一个新的元素 flatMap ：接收一个函数作为参数，将流中的每一个值都换成另一个流，然后把所有的流连接成一个流 map： 1&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper); flatMap： 1&lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper); 代码演示 1234567891011121314151617181920212223242526272829303132333435//将集合中的字符变成大写public static Stream&lt;Character&gt; filterCharacter(String str)&#123; List&lt;Character&gt; list = new ArrayList&lt;&gt;(); for (Character ch : str.toCharArray()) &#123; list.add(ch); &#125; return list.stream();&#125;@Testpublic void test6()&#123; List&lt;String&gt; list = Arrays.asList(\"aaa\",\"bbb\",\"ccc\"); list.stream() .map((str)-&gt;str.toUpperCase()) .forEach(System.out::println); people.stream() .map(Person::getName) .forEach(System.out::println); /*-------------------------------------------------------------------*/ System.out.println(\"/*-----------------------------------------------*/\"); //将集合中的字符变成大写 //将map里的函数，应用到集合中每一个元素，此时返回一个新流Stream&lt;Stream&lt;Character&gt;&gt; //此时得重新遍历新每一个新流 Stream&lt;Stream&lt;Character&gt;&gt; streamStream = list.stream() .map(StreamTest::filterCharacter); streamStream.forEach(s-&gt;&#123; s.forEach(System.out::println); &#125;); /*-------------------------------------------------------------------*/ System.out.println(\"/*-----------------------------------------------*/\"); //将所有得新流合并成一个新流，然后再遍历 list.stream() .flatMap(StreamTest::filterCharacter) .forEach(System.out::println);&#125; 3、排序1Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator); 12345678910111213//排序@Testpublic void test7()&#123; people.stream() .sorted((p1,p2)-&gt;&#123; if (p1.getAge()==p2.getAge())&#123; return p1.getName().compareTo(p2.getName()); &#125;else &#123; return p1.getAge()-p2.getAge(); &#125; &#125;) .forEach(System.out::println);&#125; 4.终止操作1.查找与匹配 allMatch ：检查是否匹配所有元素 anyMatch ：检查是否至少有一个匹配元素 noneMatch ：检查是否没有匹配元素 findFirst ：返回第一个元素 findAny ：返回当前流中的任意元素 count ：返回流中的总个数 max ：返回流中最大的 min ：返回流中最小的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758@Testpublic void test8()&#123; //allMatch ：检查是否匹配所有元素 boolean b1 = people.stream() .allMatch((p) -&gt; p.getStatus().equals(Person.Status.BUSY)); System.out.println(b1); //anyMatch ：检查是否至少有一个匹配元素 boolean b2 = people.stream() .anyMatch((p) -&gt; p.getStatus().equals(Person.Status.BUSY)); System.out.println(b2); //noneMatch ：检查是否没有匹配元素 boolean b3 = people.stream() .noneMatch((p) -&gt; p.getStatus().equals(Person.Status.BUSY)); System.out.println(b3); //findFirst ：返回第一个元素 //Optional：java8为了解决空指针异常使用了该类 //orElse()：当集合元素为空时，可以传入一个元素 Optional&lt;Person&gt; optional = people.stream() .sorted((p1, p2) -&gt; Integer.compare(p1.getAge(), p2.getAge())) .findFirst(); optional.orElse(new Person(\"zmy04\", 24, Person.Status.FREE)); System.out.println(optional.get()); //findAny ：返回当前流中的任意元素 Optional&lt;Person&gt; any = people.stream() .filter((p) -&gt; p.getStatus() == Person.Status.FREE) .findAny(); System.out.println(any); //count ：返回流中的总个数 long count = people.stream() .filter((p) -&gt; p.getStatus() == Person.Status.FREE) .count(); System.out.println(count); //max ：返回流中最大的 Optional&lt;Person&gt; max = people.stream() .filter((p) -&gt; p.getStatus() == Person.Status.FREE) .max((p1, p2) -&gt; Integer.compare(p1.getAge(), p2.getAge())); System.out.println(max.get()); //min ：返回流中最小的 Optional&lt;Person&gt; min = people.stream() .filter((p) -&gt; p.getStatus() == Person.Status.FREE) .min((p1, p2) -&gt; Integer.compare(p1.getAge(), p2.getAge())); System.out.println(min.get()); //返回最大年龄 Optional&lt;Integer&gt; maxAge = people.stream() .map(Person::getAge) .max(Integer::compareTo); System.out.println(maxAge.get());&#125; 5.规约规约map-reduce模式 1234567891011@Testpublic void test9()&#123; List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5,6,7,8,9); Integer reduce = list.stream() .reduce(0, (x, y) -&gt; x + y); System.out.println(reduce); Optional&lt;Integer&gt; ageSum = people.stream() .map(Person::getAge) .reduce(Integer::sum); System.out.println(ageSum.get());&#125; 6.收集器Collectors工具类：collect:将流转化为其他形式。接收一个Collector接口实现 123456789101112131415161718192021222324252627282930313233343536373839404142@Testpublic void test10()&#123; List&lt;String&gt; collect = people.stream() .map(Person::getName) .collect(Collectors.toList()); collect.forEach(System.out::println); Double aDouble = people.stream() .collect(Collectors.averagingInt(Person::getAge)); System.out.println(aDouble); Optional&lt;Person&gt; person = people.stream() .collect(Collectors.maxBy((p1, p2) -&gt; Integer.compare(p1.getAge(), p2.getAge()))); System.out.println(person); people.stream() .map(Person::getAge) .collect(Collectors.maxBy(Integer::compare)); System.out.println(\"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\"); Map&lt;Person.Status, List&lt;Person&gt;&gt; listMap = people.stream() .collect(Collectors.groupingBy(Person::getStatus)); System.out.println(listMap); System.out.println(\"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\"); Map&lt;Person.Status, Map&lt;String, List&lt;Person&gt;&gt;&gt; statusMapMap = people.stream() .collect(Collectors.groupingBy(Person::getStatus, Collectors.groupingBy((p) -&gt; &#123; if (p.getStatus() == Person.Status.BUSY) &#123; return \"忙\"; &#125; else &#123; return \"不忙\"; &#125; &#125;))); System.out.println(statusMapMap); //分区 System.out.println(\"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\"); Map&lt;Boolean, List&lt;Person&gt;&gt; map = people.stream() .collect(Collectors.partitioningBy((p) -&gt; p.getAge() &gt; 22)); System.out.println(map);&#125; 12345678910111213141516@Testpublic void test11()&#123; IntSummaryStatistics collect = people.stream() .collect(Collectors.summarizingInt(Person::getAge)); System.out.println(collect.getAverage()); System.out.println(collect.getMax()); System.out.println(collect.getSum()); System.out.println(collect.getMin()); System.out.println(collect.getCount()); String collect1 = people.stream() .map(Person::getName) .collect(Collectors.joining(\",\",\"===\",\"===\")); System.out.println(collect1);&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zmmmmy.github.io/categories/Java/"},{"name":"Java8新特性","slug":"Java/Java8新特性","permalink":"https://zmmmmy.github.io/categories/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zmmmmy.github.io/tags/Java/"}]},{"title":"如何搭建Hexo静态博客","slug":"Hexo/Hexo","date":"2020-07-02T09:12:33.000Z","updated":"2020-07-02T16:59:11.665Z","comments":true,"path":"posts/12e928c1.html","link":"","permalink":"https://zmmmmy.github.io/posts/12e928c1","excerpt":"","text":"","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://zmmmmy.github.io/categories/Hexo/"}],"tags":[]},{"title":"Git","slug":"Git/Git","date":"2020-07-01T15:47:26.000Z","updated":"2020-07-02T16:59:11.664Z","comments":true,"path":"posts/69c3279c.html","link":"","permalink":"https://zmmmmy.github.io/posts/69c3279c","excerpt":"还没整完","text":"还没整完","categories":[{"name":"Git","slug":"Git","permalink":"https://zmmmmy.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://zmmmmy.github.io/tags/Git/"}]},{"title":"Linux","slug":"Linux/Linux","date":"2020-07-01T15:28:44.000Z","updated":"2020-07-02T16:59:11.666Z","comments":true,"path":"posts/53d0684b.html","link":"","permalink":"https://zmmmmy.github.io/posts/53d0684b","excerpt":"这是一篇关于Linux的笔记","text":"这是一篇关于Linux的笔记 Linux一、Linux的目录结构 二、vi和vim编辑器三种模式1.正常模式 yy：拷贝当前行 5yy：拷贝向下的5行 p：粘贴 dd：删除当前行 5dd：删除向下的5行 / + 关键字：输入n查找下一个，N查找上一个 set nu,set nonu：显示/关闭行号 u：撤销 20+G：移动到第20行 gg：文首 G：文底 2.插入模式 3.命令模式 三、关机&amp;重启shutdown shutdown -h new：立即关机 shutdown -h 1：表示1分钟后关机 shutdown -r now：立即重启 halt 关机 reboot 重启 syn： 把内存的数据同步到磁盘 四、登录&amp;注销注销：logout 更换用户：su -用户名 回到上一次用户：exit 当前用户：whoami 五、用户管理 useradd [选项] 用户名 -d：指定目录 passwd 用户名：修改密码 userdel 用户名 [选项] 用户名 -r：删除家目录 查询用户信息： id 用户名 用户组 groupadd 组名 groupdel 组名 修改用户组 useradd -g 组名 用户名 新增用户直接添加用户组 usermod -g 组名 用户名 更改组 /etc/password 文件 用户(user)配置文件,记录用户的信息 /etc/shadow 口令的配置文件 用户名:加密口令:最后一次登录时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志 /etc/group 组的配置文件 组名:口令:组织标号:组内用户列表 六、如何找回丢失的root密码…………………………….以后再说吧………………………………. 七、文件目录pwd：当前路径 ls指令 [选项] 目录或文件 -a：显示所有 -l：列表显示 -h：习惯显示 cd指令 [参数] cd ~：回到家目录 cd ..：回到上级目录 mkdir [选项] 要创建的目录 -p：创建多级目录 rmdir [选项] 删除空目录，只能删除空目录 touch指令，创建一个空文件 touch 文件，文件….. cp指令：复制 cp [选项] 源文件 目标文件 -r(recursion)：递归复制，复制整个目录 \\cp ：强制覆盖 rm指令，移除目录或文件 -r：递归删除 -f：强制删除 mv指令：移动文件&amp;重命名 mv oldFile newFile cat指令：查看文件内容(只读) cat [选项] 要查看的文件 -n：显示行号 cat -n 文件名 | more 分页显示，空格下一页，回车下一行 (管道命操作) more指令，分页查看 more 文件名 快捷键：ctrl+b上一页，ctrl+f 下一页 less指令，分屏查看，懒加载，查看大文件 / ：向上查找 ？：向下查找 q：离开程序 快捷键 &gt; 指令和&gt;&gt; 指令 &gt; 输出重定向 &gt; &gt; 追加 echo控制台输出一句话 echo 内容 &gt; 文件 echo 内容 &gt;&gt; 文件 echo $PATH：输入当前环境变量 head指令：用于显示文件头部份内容(默认前十行) head -n 5 文件： 指定显示5行文件内容 tail指令：用于显示文件尾部内容(默认后五行) tail -n 5 文件：指定显示5行文件内容 tail -f ：实时监控文件变化 ln指令：创建软连接(类似快捷方式) ln -s 源目录 软连接 ！+ 行数：执行本行指令 touch指令：创建空文件 history指令：查看过去的指令 八、时间日期类 date显示当前日期 date “+%Y-%m-%d”：显示年月日 cal以日历方式查看当前时间 cal [选项] ​ 九、搜索查找类 find指令 [搜索的范围] -name [搜索条件]：按名字搜索 find指令 [搜索的范围] -size [搜索条件]：按名字搜索 +n：大于n的 -n：小于n的 n：等于n的 locate指令：快速查找文件 执行locate之前先执行updatedb更新linux是数据库 locate 要查找的文件名 grep指令和管道符号 | ，表示将一个命令输出的结果传递给后面的指令，grep通常和管道符号“|”一同使用 cat 文件名 | grep -n/-ni 查找内容 ：查找内容并带行号(区分大小写/不区分大小写) 十、压缩&amp;解压缩 gzip&amp;gunzip gzip 文件：压缩文件，不会保留源文件 gunzip 文件：解压文件 zip&amp;unzip zip [选项] XXX.zip 压缩内容：压缩文件命名为XXX.zip -r ：递归压缩，压缩整个目录 unzip [选项] ：解压缩 -d ：压缩到那个目录 tar： tar -zcvf 打包后的文件名 打包文件…….. tar -zxvf 压缩文件 -C 解压目录：解压目录要存在 十一、 组管理 chown 用户名 文件名 ：修改文件所有者 chgrp 所属组 文件名 ：修改文件所属组 usermod -g 组名 用户名：修改用户所属组 groupadd：添加组 十二、权限管理​ - rw- r– r– 第一位 - ：普通文件 d ：目录 l ：软连接 c ：字符设备 b ：块文件(硬盘…) 2~4位 所属者权限 5~7位 所属组权限 8~10位 其他用户权限 chmod：修改文件或目录的权限 chgrp：修改文件所在组 ​ chgrp 所属组 文件：改变文件所属组 -R：递归修改，修改目录下所有文件所在组 十三、定时任务调度crontab：定时任务调度设置 -e：编辑定时任务调度，编写克隆表达式 -l：查询任务 -r：删除当前任务 service crond restart：重启任务调度 十四、Linux洗盘分区和挂载lsblk 、lsblk -f：查看所有设备挂载情况 1.分区命令fdisk /dev/sdb 开始对/sdb分区 •m 显示命令列表 •p 显示磁盘分区同fdisk –l •n 新增分区 •d 删除分区 •w 写入并退出说明：开始分区后输入n，新增分区，然后选择p ，分区类型为主分区。两次回车默认剩余全部空间。最后输入w写入分区并退出，若不保存退出输入q。 2.格式化磁盘分区命令:mkfs -t ext4 /dev/sdb1其中ext4是分区类型 3.挂载: 将一个分区与一个目录联系起来， •mount 设备名称挂载目录 •例如：mount /dev/sdb1 /newdisk •umount设备名称或者挂载目录 •例如：umount/dev/sdb1 或者umount/newdis •用命令行挂载重启后会失效 4.永久挂载: ​ 通过修改/etc/fstab实现挂载​ 添加完成后执行mount –a 即刻生效​ df -h ：查询系统整体磁盘使用情况 du -h /目录： 查询指定目录的磁盘占用情况，默认为当前目录 -s指定目录占用大小汇总 -h 带计量单位 -a 含文件 –max-depth=1 子目录深度 -c 列出明细的同时，增加汇总值 tree /目录：树状显示 十五、网络设置1、开启防火墙 systemctl start firewalld 2、开放指定端口 firewall-cmd –zone=public –add-port=1935/tcp –permanent 命令含义：–zone #作用域–add-port=1935/tcp #添加端口，格式为：端口/通讯协议–permanent #永久生效，没有此参数重启后失效 3、重启防火墙 firewall-cmd –reload 4、查看端口号netstat -ntlp //查看当前所有tcp端口· netstat -ntulp |grep 1935 //查看所有1935端口使用情况· netstat -anp 查看所以有开放端口 /etc/sysconfig/network-scripts/ifcfg-ens33：网络配置文件 5.监控网络状态 基本语法 netstat [选项] 选项说明 -an 按一定顺序排列输出 -p 显示哪个进程在调用 十六、进程管理ps：来查看目前系统中，有哪些正在执行 ps详解 1)指令：ps –aux|grep xxx ，比如我看看有没有sshd服务2)指令说明,System V展示风格 •USER：用户名称 •PID：进程号 •%CPU：进程占用CPU的百分比 •%MEM：进程占用物理内存的百分比 •VSZ：进程占用的虚拟内存大小（单位：KB） •RSS：进程占用的物理内存大小（单位：KB） •TT：终端名称,缩写. •STAT：进程状态，其中S-睡眠，s-表示该进程是会话的先导进程，N-表示进程拥有比普通优先级更低的优先级，R-正在运行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止等等 •STARTED：进程的启动时间 •TIME：CPU时间，即进程使用CPU的总时间 •COMMAND：启动进程所用的命令和参数，如果过长会被截断显示 ps -ef是以全格式显示当前所有的进程 -e 显示所有进程。 -f 全格式。 ps -ef|grep xxx是BSD风格 UID：用户ID PID：进程ID PPID：父进程ID C：CPU用于计算执行优先级的因子。数值越大，表明进程是CPU密集型运算，执行优先级会降低；数值越小，表明进程是I/O密集型运算，执行优先级会提高 STIME：进程启动的时间 TTY：完整的终端名称 TIME：CPU时间 CMD：启动进程所用的命令和参数 pstree：查看进程树 常用选项： -p :显示进程的PID -u :显示进程的所属用户 top指令： top与ps命令很相似。它们都用来显示正在执行的进程。Top与ps最大的不同之处，在于top在执行一段时间可以更新正在运行的的进程。 top [选项] -d秒数：指定top命令每隔几秒更新。默认是3秒在top命令的交互模式当中可以执行的命令 -i：使top不显示任何闲置或者僵死进程。 -p：通过指定监控进程ID来仅仅监控某个进程的状态。 操作 P：以CPU使用率排序，默认就是此项 M：以内存的使用率排序 N：以PID排序 q：退出top 十七、RPM和YUMRPM介绍：一种用于互联网下载包的打包及安装工具，它包含在某些Linux分发版中。它生成具有.RPM扩展名的文件。RPM是RedHat Package Manager（RedHat软件包管理工具）的缩写，类似windows的setup.exe，这一文件格式名称虽然打上了RedHat的标志，但理念是通用的。 查询已安装的rpm列表rpm –qa rpm包的其它查询指令：rpm -qa :查询所安装的所有rpm软件包rpm -qa | morerpm -qa | grep X [rpm -qa | grep firefox ]rpm -q 软件包名:查询软件包是否安装rpm -q firefoxrpm -qi 软件包名：查询软件包信息rpm -qi file 卸载rpm包：•基本语法rpm -e RPM包的名称•细节讨论 1) 如果其它软件包依赖于您要卸载的软件包，卸载时则会产生错误信息。如：$ rpm -e fooremoving these packages would break dependencies:foo is needed by bar-1.0-12) 如果我们就是要删除foo这个rpm 包，可以增加参数–nodeps ,就可以强制删除，但是一般不推荐这样做，因为依赖于该软件包的程序可能无法运行如：$ rpm -e –nodeps foo 安装rpm包：•基本语法rpm -ivh RPM包全路径名称•参数说明i=install 安装v=verbose 提示h=hash 进度条 安装JDK： 安装步骤 先将软件通过xftp5 上传到/opt 下 解压缩到/opt 配置环境变量的配置文件vim /etc/profile JAVA_HOME=/opt/jdk1.7.0_79 PATH=/opt/jdk1.7.0_79/bin:$PATH export JAVA_HOME PATH 启动tomcat ./startup.sh 十九、服务的启动和停止systemctl start firewalld systemctl stop firewalld systemctl [command] [unit] command 主要有： start：立刻启动后面接的 unit。 stop：立刻关闭后面接的 unit。 restart：立刻关闭后启动后面接的 unit，亦即执行 stop 再 start 的意思。 reload：不关闭 unit 的情况下，重新载入配置文件，让设置生效。 enable：设置下次开机时，后面接的 unit 会被启动。 disable：设置下次开机时，后面接的 unit 不会被启动。 status：目前后面接的这个 unit 的状态，会列出有没有正在执行、开机时是否启动等信息。 is-active：目前有没有正在运行中。is-enable：开机时有没有默认要启用这个 unit。 kill ：不要被 kill 这个名字吓着了，它其实是向运行 unit 的进程发送信号。 show：列出 unit 的配置。 mask：注销 unit，注销后你就无法启动这个 unit 了。 unmask：取消对 unit 的注销。 Linux(补充) 开启防火墙 systemctl start firewalld.service 防火墙开机启动 systemctl enable firewalld.service 关闭防火墙 systemctl stop firewalld.service 查看防火墙状态 firewall-cmd –state 重载防火墙配置 firewall-cmd –reload 添加单个单端口 firewall-cmd –permanent –zone=public –add-port=81/tcp 添加多个端口 firewall-cmd –permanent –zone=public –add-port=8080-8083/tcp 删除某个端口 firewall-cmd –permanent –zone=public –remove-port=81/tcp 针对某个 IP开放端口 firewall-cmd –permanent –add-rich-rule=”rule family=”ipv4” source address=”192.168.142.166” port protocol=”tcp” port=”6379” accept” firewall-cmd –permanent –add-rich-rule=”rule family=”ipv4” source address=”192.168.0.233” accept” 删除某个IP firewall-cmd –permanent –remove-rich-rule=”rule family=”ipv4” source address=”192.168.1.51” accept” 针对一个ip段访问 firewall-cmd –permanent –add-rich-rule=”rule family=”ipv4” source address=”192.168.0.0/16” accept” firewall-cmd –permanent –add-rich-rule=”rule family=”ipv4” source address=”192.168.1.0/24” port protocol=”tcp” port=”9200” accept” 添加操作后别忘了执行重载 firewall-cmd –reload 重启防火墙 systemctl restart firewalld 端口列表 firewall-cmd –list-all 重启网卡：service network restart","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zmmmmy.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://zmmmmy.github.io/tags/Linux/"}]},{"title":"SpringBoot","slug":"SpringBoot/SpringBoot","date":"2020-07-01T15:28:44.000Z","updated":"2020-07-03T03:12:44.542Z","comments":true,"path":"posts/6f2612a2.html","link":"","permalink":"https://zmmmmy.github.io/posts/6f2612a2","excerpt":"这是一篇关于SpringBoot的笔记","text":"这是一篇关于SpringBoot的笔记 一、SpringBoot启动类的加载 二、配置文件 1.配置文件SpringBoot使用一个全局的配置文件，配置文件名字是固定的 application.properties application.yaml 配置文件的作用：修改SpringBoot自动配置的默认值 2.YAML(YML) 格式 12key: key: value 值的写法 字符串默认不用加单引号或双引号 如果加上 “ “：双引号，不会转义字符串的特殊字符，特殊字符会表达出本身的意思 ‘ ’ ：单引号，会表达出字符串的意思 对象、map的写法 123person: name: zmy age: 25 行内写法 1person: &#123;name: zmy,age: 25&#125; 数组（List、Set） 1234list: - num1 - num2 - num3 行内写法 1list: [unm1,num2,num3] 将配置文件而的值映射到组件中 JavaBean 1234567891011@Data //lombok注解@ToString //lombok注解@Component //将本类加载进Spring容器@Validated //JSR303数据校验@ConfigurationProperties(prefix = \"person\") //告诉SpringBoot将本类中所有属性和配置文件进行绑定public class Person &#123; private String name; private int age; private ArrayList&lt;String&gt; phone; private HashMap&lt;String,String&gt; like;&#125; yml配置文件（idae会有提示，需要加入依赖） 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; yml 123456789person: name: zmy age: 25 phone: - iPhone - XiaoMi like: game: LOL guitar: YAMAHA properties 12345person.name=zmyperson.age=25person.phone=iPhone,XiaoMiperson.like.play=LOLperson.like.guitar=YAMAHA 3.@ConfigurationProperties 和 @Value @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 @ConfigurationProperties 123456789101112@Data@ToString@Component@PropertySource(\"classpath:person.properties\")@ConfigurationProperties( prefix = \"person\" )//@Validatedpublic class Person &#123; private String name; private int age; private ArrayList&lt;String&gt; phone; private HashMap&lt;String,String&gt; like;&#125; @Value 123456789101112@Data@ToString@Component@PropertySource(\"classpath:person.properties\") //引入指定资源public class Person &#123; @Value(\"$&#123;person.name&#125;\") private String name; @Value(\"#&#123;24+1&#125;\") //SpEL表达式 private int age; private ArrayList&lt;String&gt; phone; private HashMap&lt;String,String&gt; like;&#125; 4.@PropertySource 和 @ImportResource@PropertySource：导入指定资源 123456789101112@Data@ToString@Component@PropertySource(\"classpath:person.properties\") //引入指定资源@ConfigurationProperties( prefix = \"person\" )//@Validatedpublic class Person &#123; private String name; private int age; private ArrayList&lt;String&gt; phone; private HashMap&lt;String,String&gt; like;&#125; @ImportResource：导入配置文件 123456789@SpringBootApplication /.//SpringBoot启动类@ImportResource(\"classpath:beans.xml\") //导入指定配置文件public class SpringbootDemo01Application &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootDemo01Application.class, args); &#125;&#125; 5.SpringBoot推荐给容器中添加组件的方式全注解方式@Configuration：表明当前是一个配置类，代替之前的Spring配置文件 @Bean：将当前的返回值添加到容器中 12345678910@Configurationpublic class MyAppConfig &#123; //将当前方法的返回值添加到容器中 //容器中组件的id就是当前方法名 @Bean public HelloDemo helloDemo()&#123; System.out.println(\"Bean给容器中添加组件了\"); return new HelloDemo(); &#125;&#125; 6.配置文件占位符12345person.name=钟明原$&#123;random.uuid&#125; 随机数person.age=25person.phone=iPhone,XiaoMiperson.like.play=$&#123;person.game:LOL&#125;_CS:GO 引用值，并给定默认值person.like.guitar=$&#123;person.like.play&#125;&amp;YAMAHA 引用值 7.Profile多环境1.多Profile文件我们在编写配置类的时候，文件名可以是 application-{profile}.properties/yml 12server.port=8080spring.profiles.active=dev 激活该环境 2.yml支持多文档块方式123456789101112131415server: port: 8080spring: profiles: active: dev---server: port: 8083spring: profiles: dev---server: port: 8084spring: profiles: prop 3.激活指定的profile1.使用设置 2.使用命令行 先打包 java -jar springboot-demo01-0.0.1-SNAPSHOT.jar –spring.profiles.active=dev 3.使用虚拟机参数 -Dspring.profiles.active=dev 4.配置文件加载位置 file: ./config/ file: ./ file: classpath:/config file: classpath:/ （默认） 优先级由高到低，高优先级的配置会覆盖低优先级的配置。并且会==互补配置== 还可以通过命令行参数的方式指定配置文件 先打包 12java -jar spring-boot-config-0.0.1-SNAPSHOT.jar --spring.config.additional-location=D:/application.properties 5.外部配置文件加载顺序1.命令行参数 123java -jar spring-boot-config-0.0.1-SNAPSHOT.jar --server.port=8089 --server.servlet.context-path=/test 2.外部和内部的配置文件 ==由jar外向jar包内进行寻找== ==优先加载带profiles的配置文件== 1.jar包外部的application-{profiles}.properties/.yml 2.jar内外部的application-{profiles}.properties/.yml ==再加载不带profiles的配置文件== 1.jar包外部的application.properties/.yml 2.jar内外部的application.properties/.yml 三、SpringBoot的自动配置 spring-boot-starter-xxxxx：导入组件所需要的依赖 1.META-INF/spring.factories下的文件 2.xxxAutoConfiguration每一个xxxAutoConfiguration类都是容器中的一个组件，用他们来做自动配置 以HttpEncodingAutoConfiguration为例解释自动配置原理 1234567891011121314151617181920212223242526272829303132//表示这是一个自动配置类@Configuration(proxyBeanMethods = false) //启用指定类的@ConfigurationProperties功能，将配置文件中的值和HttpProperties绑定起来，并把HttpProperties加入到容器中@EnableConfigurationProperties(HttpProperties.class) //组合疏注解，底层是@Conditiona注解，根据不同条件，如果满足条件，整个配置类里的配置就会生效//判断当前是否为web应用，如果是，当前配置类生效@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)//判断当前是否有CharacterEncodingFilter类//CharacterEncodingFilter----&gt;SpringMVC中解决乱码的过滤器@ConditionalOnClass(CharacterEncodingFilter.class)//判断配置文件中置否存在某个配置：spring.http.encoding.enabled,如果不存在判断也是成立的//即使不配置也是默认生效的：spring.http.encoding.enabled=true@ConditionalOnProperty(prefix = \"spring.http.encoding\", value = \"enabled\", matchIfMissing = true)public class HttpEncodingAutoConfiguration &#123; //他已经和SPringBoot配置文件映射了 private final HttpProperties.Encoding properties; //只有一个有参构造器，参数就会从容器中拿到 public HttpEncodingAutoConfiguration(HttpProperties properties) &#123; this.properties = properties.getEncoding(); &#125; //给容器中添加一个组件，这个组件的值，需要从properties获取 @Bean //在该组件不存在时生效 @ConditionalOnMissingBean public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE)); return filter; &#125; ==根据当前不同条件判断，决定这个配置类是否生效== 一旦配置类生效，这个配置类就会为容器添加各种组件，这些组建的属性是从对应的==xxxxProperties==类中获取的 3.xxxxPropertiesxxxxProperties类又和配置文件时绑定的 所有在配置文件中配置的属性都在xxxxProperties类中封装着，配置文件可以配置什么就可以参考对应这个属性 HttpProperties 12@ConfigurationProperties(prefix = \"spring.http\")public class HttpProperties &#123; 4.精髓&amp;总结 SpringBoot启动会加载大量的自动配置类 首先看我们需要的功能SpringBoot有没有自动配置 再来看自动配置类到底配置了那些组件，如果配置了我们需要的组件，就不需要再配置了 给容器中的自动配置类添加组件的时候，会从xxxxProperties类中获取某些属性。我们就可以在配置文件中指定这些属性的值 xxxxAutoConfiguration：自动配置类给容器中添加组件 xxxxProperties：封装了配置文件中相关的属性 5.@Conditional派生注解@Conditional派生注解（Spring注解版原生的@Conditional作用）作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效； @Conditional扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean； @ConditionalOnMissingBean 容器中不存在指定Bean； @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 6.自动配置报告通过debug=true属性查看配置情况 12#开启SpringBoot的debugdebug=true 四、日志1.市面上的日志框架JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j…. 日志门面 （日志的抽象层） 日志实现 JCL（Jakarta Commons Logging） SLF4j（Simple Logging Facade for Java） jboss-logging Log4j JUL（java.util.logging） Log4j2 Logback 左边选一个门面（抽象层）、右边来选一个实现； 日志门面： SLF4J； 日志实现：Logback； SpringBoot：底层是Spring框架，Spring框架默认是用JCL； ==SpringBoot选用 SLF4j和logback；== 2.SEL4J的使用 1.如何在系统中使用SLF4J以后在开发的时候，不应该直接调用日志的实现类，而是调用日志抽象层里面的方法 给系统里导入slf4j的jar和logback的实现jar 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info(\"Hello World\"); &#125;&#125; 每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是要导入具体实现框架的配置文件 2.统一日志在一个项目中可能存在多个框架这就导致了多个日志框架一起使用的情况 比如Spring用的是Commons-logging，Hibernate用的是jboss-logging……… 如何统一日志，即使是别的框架也和我使用同一个日志框架呢 如何让系统中所有的日志都统一到slf4j 将系统中的其他日志框架先排除出去 用中间包替换原有的日志框架 导入slf4j的实现框架 3.SpringBoot日志关系SpringBoot最基本模块 123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.2.7.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; SpringBoot日志功能启动器 123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;version&gt;2.2.7.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; 总结 SpringBoot底层原理使用的是slf4j+logback的方式进行日志记录 SpringBoot也把其他日志替换成了slf4j 中间替换包 3.日志的使用123456789101112131415161718@SpringBootTestclass SpeingBootLogApplicationTests &#123; // Logger logger = LoggerFactory.getLogger(getClass()); @Test void contextLoads() &#123; //日志的级别 //由低到高：trace&lt;debug&lt;info&lt;warn&lt;error //可以调整输出日志的级别，日志就会在这个级别以后的高级别生效 logger.trace(\"这是trace日志\"); logger.debug(\"这是debug日志\"); /.//SpringBoot默认使用的是info级别的，也就是root级别 logger.info(\"这是info日志\"); logger.warn(\"这是warn日志\"); logger.error(\"这是error日志\"); &#125;&#125; 配置文件 12345678910111213#设置日志级别logging.level.com.zmy=trace#可以指定路径和log文件的名字#不能与logging.file.path同时使用logging.file.name=springboot1.log#不能指定log的名字, 使用缺省值spring.log#不能与logging.file.name同时使用#/代表文件磁盘根目录#logging.file.path=.//SpringBootDemo3/#在控制台输出日志的格式logging.pattern.console=%d&#123;yyyy-MM-dd&#125; [ %thread ] - [ %-5level ] [ %logger&#123;50&#125; : %line ] - %msg%n#在文件输出日志的格式logging.pattern.file=%d&#123;yyyy-MM-dd&#125; [ %thread ] - [ %-5level ] [ %logger&#123;50&#125; : %line ] -%msg%n --&gt; %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger{50} 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符日志配置文件 Logging System Customization Logback logback-spring.xml,logback-spring.groovy,logback.xml,logback.groovy Log4j2 log4j2-spring.xml or log4j2.xml JDK (Java Util Logging) logging.properties logback.xml：直接被日志框架识别 logback-spring.xml：日志框架不加载该文件，由SpringBoot加载，可以使用SpringBoot的高级功能 SpringBoot日志高级功能 123456&lt;springProfile name=\"dev\"&gt; &lt;pattern&gt;输出格式&lt;/pattern&gt;&lt;/springProfile&gt;&lt;springProfile name=\"!dev\"&gt; &lt;pattern&gt;输出格式&lt;/pattern&gt;&lt;/springProfile&gt; 五、Web开发 WebMvcAutoConfiguration.java WebMvc自动配置类 1.SpringBoot对静态资源的映射规则public enum StaticResourceLocation——–&gt;静态资源的通用位置的枚举类 getResourceLocations——–&gt;获取资源位置 addResourceHandlers——–&gt;添加资源处理程序 1.第一种映射规则classpath:/META-INF/resources/webjars/ webjars:SpringBoot是通过jar的打包方式，所以静态资源可以以jar包的方式引入 在pom.xml添加依赖 123456&lt;!--引入jquery的webjars--&gt;&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt;&lt;/dependency&gt; webjar的结构 2.第二种映射规则/** ：访问当前项目任何资源（静态资源文件夹） 任何资源如果没人处理就在一下资源目录寻找 12345classpath:&#x2F;META-INF&#x2F;resources&#x2F;&quot;&quot;classpath:&#x2F;resources&#x2F;&quot;&quot;classpath:&#x2F;static&#x2F;&quot;&quot;classpath:&#x2F;public&#x2F;&quot;&#x2F;&quot;:当前项目的根路径 比如：localhost:8080/abc 就等于去静态资源文件夹里找abc 3.资源设置类ResourceProperties.java： 资源设置类：可以对资源进行设置 123//可以设置和资源有关的设置@ConfigurationProperties(prefix = \"spring.resources\", ignoreUnknownFields = false)public class ResourceProperties &#123; 1spring.resources.static-locations=设置静态资源路径 2.欢迎页映射 3.模板引擎JSP、Velocity、Freemarker、Thymeleaf…….. SpringBoot推荐使用Thymeleaf 1.引入Thymeleaf1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; ThymeleafProperties配置类 加载classpath:/templates/xxxxx.html下的文件 12345@ConfigurationProperties(prefix = \"spring.thymeleaf\")public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING = StandardCharsets.UTF_8; public static final String DEFAULT_PREFIX = \"classpath:/templates/\"; public static final String DEFAULT_SUFFIX = \".html\"; 2.使用Thymeleaf引入命名空间 1&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; 3.Thymeleaf语法规则 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Variable Expressions: $&#123;...&#125; #获取变量值#获取对象属性、调用方法#使用内置对象 Selection Variable Expressions: *&#123;...&#125;#变量选择表达式#功能上和$&#123;...&#125;一样#配合th:object使用&lt;div th:object=\"$&#123;session.user&#125;\"&gt; &lt;p&gt;Name: &lt;span th:text=\"*&#123;firstName&#125;\"&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text=\"*&#123;lastName&#125;\"&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=\"*&#123;nationality&#125;\"&gt;Saturn&lt;/span&gt;.&lt;/p&gt;&lt;/div&gt;Message Expressions: #&#123;...&#125;#获取国际化内容Link URL Expressions: @&#123;...&#125;#定义urlFragment Expressions: ~&#123;...&#125;#引用表达式Text literals: , ,…'one text''Another one!'Number literals: , , , ,…0343.012.3Boolean literals: , truefalseNull literal: nullLiteral tokens: , , ,…onesometextmainString concatenation: +Literal substitutions: |The name is $&#123;name&#125;|Arithmetic operations:Binary operators: , , , , +-*/%Minus sign (unary operator): -Binary operators: , andorBoolean negation (unary operator): , !notComparisons and equality:Comparators: , , , (, , , &gt;&lt;&gt;=&lt;=gtltgele)Equality operators: , (, ==!=eqne)Conditional operators:If-then: (if) ? (then)If-then-else: (if) ? (then) : (else)Default: (value) ?: (defaultvalue)Special tokens:No-Operation: _ [[标签内容]]：不转义 [(标签内容)]：转义 4.重定向与转发 4.Spring MVC自动配置Spring MVC核心组件 DispatcherServlet：调度器 ViewResolver：视图解析器 Spring MVC Auto-configuration 以下是SpringBoot对SpringMVC的自动配置 Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. 自动配置了ViewResolver（视图解析器，根据返回值返回视图对象） ContentNegotiatingViewResolver ：组合所有视图解析器 如何定制：我们可以自己给容器中添加一个视图解析器==添加到容器==ContentNegotiatingViewResolver 就会自动的将其组合进来 验证：———&gt;DispatcherServlet——–&gt;doDispatch，查看是否加入 @Bean public ViewResolver myViewResolver(){ return new MyViewResolver(); } private static class MyViewResolver implements ViewResolver{ @Override public View resolveViewName(String viewName, Locale locale) throws Exception { return null; } } &lt;!--￼36--&gt; ==SpringBoot扩展方式== 编写一个配置类（@Configuration），是==WebMvcConfigurer==类型的，不能标注@EanableWebMvc 12345678910//视图控制器@Configurationpublic class MyMvcConfig implements WebMvcConfigurer &#123; //添加视图解析器 //将/zmy映射到success @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(\"/zmy\").setViewName(\"success\"); &#125;&#125; 2.SpringMVC的自动配置原理WebMvcAutoConfiguration是SpringMVC的自动配置类 WebMvcAutoConfigurationAdapter：Web Mvc自动配置适配器 12345@Configuration(proxyBeanMethods = false)@Import(EnableWebMvcConfiguration.class)@EnableConfigurationProperties(&#123; WebMvcProperties.class, ResourceProperties.class &#125;)@Order(0)public static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer &#123; @Import(EnableWebMvcConfiguration.class) 效果：有的WebMVC的配置一起起作用 3.全面接管SpringBootMVCSpringBoot对SpringMVC的自动配置都不需要了，所有的都是自己来配置 If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc, or alternatively add your own @Configuration-annotated DelegatingWebMvcConfiguration as described in the Javadoc of @EnableWebMvc. 如果要完全控制Spring MVC，可以添加带有@EnableWebMvc注释的自己的@Configuration，或者添加自己的@Configuration注释的DelegatingWebMvcConfiguration，如@EnableWebMvc的Javadoc中所述。 ==5.如何修改SpringBoot的默认配置==org.springframework.boot.autoconfigure.web：web的所有自动配置场景； 模式： SpringBoot在自动配置类，先看容器中有没有用户自己注册进去的组件 （@ConditionalOnMissingBean），如果有就用用户配置的，没有就自动配置。如果有组件可以有多个就将用户配置的，和默认配置的结合起来（ViewResolver） 在SpringBoot中有非常多的xxxxConfigurer帮助我们进行扩展配置，比如==WebMvcConfigurer== 在SpringBoot中有非常多的xxxxCustomizer帮助我们进行定制配置，比如==WebServerFactoryCustomizer== 六、RestfulCRUD 1.默认访问首页（视图控制器）视图控制器 须在WebMvc配置类添加 1234567@Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(\"/index.html\").setViewName(\"index\"); registry.addViewController(\"/\").setViewName(\"index\"); registry.addViewController(\"/index\").setViewName(\"index\"); registry.addViewController(\"/main.html\").setViewName(\"dashboard\"); &#125; 2.国际化 编写国际化配置文件 使用ResourceBundleMessageSource管理国际化资源文件 在页面使用fmt:message取出国际化内容 步骤： 编写国际化配置文件，抽取页面要显示的国际化消息 国际化配置文件 SpringBoot已经自动配置好了ResourceBundleMessageSource国际化资源管理组件 在页面获取国际化内容：使用#{………}获取国际化内容 根据浏览器语言设置页面语言 原理： Locale（区域信息对象）， LocaleResolver（语言环境解析器） 12345678910111213141516//WebMvcAutoConfiguration.java@Bean@ConditionalOnMissingBean //判断是否有该组件@ConditionalOnProperty(prefix = \"spring.mvc\", name = \"locale\")public LocaleResolver localeResolver() &#123; //判断，如果mvcProperties（mvc配置文件里的getLocaleResolver）等于LocaleResolver.FIXED（固定的），使用固定的值 if (this.mvcProperties.getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123; return new FixedLocaleResolver(this.mvcProperties.getLocale()); &#125; //使用请求头中的国际化信息 AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver;&#125;//如果请求头没有带国际化信息就用默认的//请求头带了信息，就用请求头的 3.登录页面开发期间模板引擎修改以后，要实时生效 Ctrl+F9重新编译页面 禁用模板引擎的缓存：spring.thymeleaf.cache=false 4.拦截器 实现HandlerInterceptor接口 在WebMvc配置类里添加拦截器 拦截器会过滤静态资源，需放行 1234567891011121314151617181920212223242526public class LoginHandlerInterceptor implements HandlerInterceptor &#123; //目标方法执行之前 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; HttpSession session = request.getSession(); Object user = session.getAttribute(\"user\"); if (user==null)&#123; request.setAttribute(\"msg\",\"没有权限\"); request.getRequestDispatcher(\"/index.html\").forward(request,response); return false; &#125; else &#123; return true; &#125; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; //目标方法执行之后 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; 12345@Overridepublic void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns(\"/**\") .excludePathPatterns(\"/index.html\",\"/index\",\"/\",\"/user/login\",\"/asserts/**\");&#125; 5.Restful风格路径格式：URI:/资源名称/资源标识 普通 Restful 查询 getXXX XXX—GET 添加 addXXX?xxx XXX—POST 修改 updateXXX?id=xxx&amp;xxx=xxx XXX/{id}—PUT 删除 deleteXXX?id=xxx XXX/{id}—DELETE 实验要求的请求架构 请求URI 请求方式 查询所有员工 emps GET 查询某个员工 emp/{id} GET 来到添加页面 emp GET 添加员工 emp POST 来到修改页面（回显） emp/{id} GET 修改 emp PUT 删除员工 emp/{id} DELETE 6.发送PUT,DELETE请求 表单的提交方式为POST 有”_method”的标签 type=”hidden” value为请求方式 1&lt;input type=\"hidden\" name=\"_method\" value=\"put\" th:if=\"$&#123;emp!=null&#125;\"&gt; 七、错误页面 可以参考ErrorMvcAutoConfiguration错误处理自动配置 给容器中添加了以下组件 DefaultErrorAttributes 帮我们在页面共享信息,可以用这些属性定制页面 12&lt;h1&gt;status：[[$&#123;status&#125;]]&lt;/h1&gt;&lt;h1&gt;timestamp：[[$&#123;timestamp&#125;]]&lt;/h1&gt; timestamp：时间戳 status：状态码 error：错误提示 exception：异常对象 message：异常消息 errors：JSR303数据校验的错误 BasicErrorController 基本错误视图控制器，注册错误视图，往里面加错误信息 ErrorPageCustomizer 错误页面定制器，寻找错误页面位置 DefaultErrorViewResolver 寻找匹配的页面/error下的404.html、4xx.html……………. 步骤： 一但系统出现4XX或者5XX之类的错误；ErrorPageCustomizer就会生效（定制错误响应规则）；就会来到/error请求；就会被BasicErrorController处理；去哪个页面就会被DefaultErrorViewResolver解析处理 八、定制错误信息 1.异常处理 @ControllerAdvice：全局异常处理 @ExceptionHandler ：注解用来指明异常的处理类型 这样只能返回JSON的数据，不能区分客户端和浏览器 2.如何自适应浏览器和客户端 使用转发return “forward:/error”；让SpringBoot处理 因为SpringBoot处理/error请求时要获取状态码所以我们自己的错误处理器要加上，否则相应的是200 request.setAttribute(\"javax.servlet.error.status_code\",500); &lt;!--￼45--&gt; 2.第二种方式继承DefaultErrorAttributes并复写getErrorAttributes（获取错误属性）方法，这样既可以得到自己编写的错误信息，也可以得到SpringBoot为我们提供的Attributes。 原理 SpringBoot获取错误信息的方式 进入/error请求BasicErrorController就会处理请求，所以如果想要加入自己的错误信息，只要继承父类，然后覆写DefaultErrorAttributes即可 九、配置嵌入式Servlet容器1.修改Web容器配置SpringBoot默认使用的是嵌入式Servlet容器（Tomcat）； SpringBoot默认使用TomCat作为Servlet容器 如何定制和修改Servlet容器相关配置 修改和server相关的配置（ServerProperties） 1234server.port=8080server.servlet.context-path=/zmy#Tomcat相关配置server.tomcat.xxxx= 编写一个WebServerFactoryCustomizer来修改容器的配置 123456789@Beanpublic WebServerFactoryCustomizer&lt;ConfigurableWebServerFactory&gt; webServerFactoryCustomizer()&#123; return new WebServerFactoryCustomizer&lt;ConfigurableWebServerFactory&gt;() &#123; @Override public void customize(ConfigurableWebServerFactory factory) &#123; factory.setPort(8083); &#125; &#125;;&#125; 2.注册三大组件12345678910111213141516171819202122232425262728//Server的一些配置@Configurationpublic class MyServerConfig &#123; //配置TomCat @Bean public WebServerFactoryCustomizer&lt;ConfigurableWebServerFactory&gt; webServerFactoryCustomizer()&#123; return new WebServerFactoryCustomizer&lt;ConfigurableWebServerFactory&gt;() &#123; @Override public void customize(ConfigurableWebServerFactory factory) &#123; factory.setPort(8083); &#125; &#125;; &#125; //添加一个Servlet @Bean public ServletRegistrationBean&lt;HttpServlet&gt; myServletServletRegistrationBean()&#123; ServletRegistrationBean&lt;HttpServlet&gt; servletBean = new ServletRegistrationBean&lt;HttpServlet&gt;(new MyServlet()); servletBean.addUrlMappings(\"/zzz\"); return servletBean; &#125; //添加一个监听器 @Bean public ServletListenerRegistrationBean myServletListenerRegistrationBean()&#123; ServletListenerRegistrationBean&lt;EventListener&gt; bean = new ServletListenerRegistrationBean&lt;&gt;(new MyListener()); return bean; &#125;&#125; SpringBoot帮我们配置了SpringMVC的时候，自动注册了SpringMVC的前端控制器 1234567891011@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)@ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)public DispatcherServletRegistrationBean dispatcherServletRegistration(DispatcherServlet dispatcherServlet, WebMvcProperties webMvcProperties, ObjectProvider&lt;MultipartConfigElement&gt; multipartConfig) &#123; DispatcherServletRegistrationBean registration = new DispatcherServletRegistrationBean(dispatcherServlet, webMvcProperties.getServlet().getPath()); registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME); registration.setLoadOnStartup(webMvcProperties.getServlet().getLoadOnStartup()); multipartConfig.ifAvailable(registration::setMultipartConfig); return registration;&#125; 十、配置嵌入式Servlet容器==（先跳过）==SpringBoot默认内置了TomCat 怎么使用其他Web容器呢 Jetty（适合长连接） Undertow（高并发，不支持Jsp） ==先排除TmoCat再引入其他web容器== SpringBoot嵌入式容器的配置 十一、Docker 1.简介Docker是一个开源的应用容器引擎；是一个轻量级容器技术； Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像； 运行中的这个镜像称为容器，容器启动是非常快速的。 2.核心概念docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）； docker客户端(Client)：连接docker主机进行操作； docker仓库(Registry)：用来保存各种打包好的软件镜像； docker镜像(Images)：软件打包好的镜像；放在docker仓库中； docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用 使用Docker的步骤： 安装Docker 去Docker仓库找到这个软件对应的镜像； 使用Docker运行这个镜像，这个镜像就会生成一个Docker容器； 对容器的启动停止就是对软件的启动停止； 3.安装Docker1.安装linux虚拟机 VMWare、VirtualBox（安装）； 导入虚拟机文件centos7-atguigu.ova； 双击启动linux虚拟机;使用 root/ 123456登陆 使用客户端连接linux服务器进行命令操作； 设置虚拟机网络； 桥接网络==选好网卡==接入网线； 设置好网络以后使用命令重启虚拟机的网络 1service network restart 查看linux的ip地址 1ip addr 使用客户端连接linux； 2.安装Docker123456789101112131、检查内核版本，必须是3.10及以上uname -r2、安装dockeryum install docker3、输入y确认安装4、启动docker[root@localhost ~]# systemctl start docker[root@localhost ~]# docker -vDocker version 1.12.6, build 3e8e77d/1.12.65、开机启动docker[root@localhost ~]# systemctl enable docker6、停止dockersystemctl stop docker 4.Docker命令 操作 命令 说明 检索 docker search 关键字 eg：docker search redis 我们经常去docker hub上检索镜像的详细信息，如镜像的TAG。 拉取 docker pull 镜像名:tag :tag是可选的，tag表示标签，多为软件的版本，默认是latest 列表 docker images 查看所有本地镜像 删除 docker rmi ./SpringBoot/https://cdn.jsdelivr.net/gh/Zmmmmy/Zmmmmy.github.io@master/posts/6f2612a2/image-id 删除指定的本地镜像 查找镜像 docker search mysql 5.容器操作 操作 命令 说明 运行 docker run –name 自定义容器名称 -d 镜像名称 –name：自定义容器名称 -d：后台运行 容器列表 docker ps 查看运行的中的容器，加 -a 可以查看所有容器 停止 docker stop 容器名称/容器id 停止当前运行的容器 启动 docker start 容器名称/容器id 启动容器 删除 docker rm 容器id 删除容器 端口映射 -p 映射端口:容器中的端口 docker run -d -p 映射端口:容器中的端口 –name 自定义容器名称 镜像名称 容器日志 docker loger 容器名称/容器id 为什么要进行端口映射？ 在阿里拉取的镜像访问TomCat会出现404，解决方法 docker exec -it mytomcat /bin/bash 将webapps.dist改为webapps mv webapps.dist webapps 1.将tomcat添加进容器 docker run -d -p 8888:8080 –name mytomcat tomcat 2.将MySql添加进容器docker run -d -p 3306:3306 –name mysql01 -e MYSQL_ROOT_PASSWORD=183786 mysql 高版本mysql会遇到问题 docker exec -it 容器名 对远程连接进行授权：GRANT ALL ON . TO ‘root’@’%’; 更改密码的加密规则：ALTER USER ‘root’@’%’ IDENTIFIED BY ‘password’ PASSWORD EXPIRE NEVER; 更改root的密码：ALTER USER ‘root’@’%’ IDENTIFIED WITH mysql_native_password BY ‘123456’; 刷新权限：flush privileges; 十二、SpringBoot&amp;JDBC 123456spring: datasource: username: root password: '183786' url: jdbc:mysql://192.168.1.100:3306/jdbc?serverTimezone=UTC driver-class-name: com.mysql.cj.jdbc.Driver 效果： ​ 默认使用的是com.zaxxer.hikari.HikariDataSource作为数据源 ​ 数据源所有的相关配置都在DataSourceProperties里面 自动配置原理： 参考DataSourceConfiguration，根据数配置创建数据源，默认使用Hikari数据源，也可以使用spring.datasource.type指定自定义的数据源类型 SpringBoot默认支持的数据源： 也可以自定义数据源类型 1234protected static &lt;T&gt; T createDataSource(DataSourceProperties properties, Class&lt;? extends DataSource&gt; type) &#123; //使用DataSourceBuilder创建数据源，；利用反射创建相应的type数据源并绑定属性 return (T) properties.initializeDataSourceBuilder().type(type).build();&#125; 启动程序时加载建表sql将sql文件命名为schema-.sql、data-*sql就会自动的执行这些sql文件 1234567891011#配置数据源spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://192.168.1.100:3306/jdbc?serverTimezone=GMT username: root password: '183786' #自定义文件 schema: - classpath:zmy.sql initialization-mode: always 整合druid数据源引入druid依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.8&lt;/version&gt;&lt;/dependency&gt; 使用type: com.alibaba.druid.pool.DruidDataSource切换数据源 12345678910spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://192.168.1.100:3306/jdbc?serverTimezone=GMT username: root password: '183786' schema: - classpath:zmy.sql initialization-mode: always type: com.alibaba.druid.pool.DruidDataSource 配置监控druid123456789101112131415161718192021222324252627282930@Configurationpublic class DruidConfig &#123; @ConfigurationProperties(prefix = \"spring.datasource\") @Bean public DataSource dataSource()&#123; return new DruidDataSource(); &#125; @Bean public ServletRegistrationBean&lt;StatViewServlet&gt; bean()&#123; ServletRegistrationBean bean = new ServletRegistrationBean&lt;StatViewServlet&gt;(new StatViewServlet(),\"/druid/*\"); Map&lt;String ,String&gt; map = new HashMap&lt;&gt;(); map.put(\"loginUsername\",\"admin\"); map.put(\"loginPassword\",\"123456\"); map.put(\"allow\",\"\"); bean.setInitParameters(map); return bean; &#125; @Bean public FilterRegistrationBean filterRegistrationBean()&#123; FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); Map&lt;String ,String&gt; map = new HashMap&lt;&gt;(); map.put(\"exclusions\",\"*.js,*.css,/druid/*\"); bean.setInitParameters(map); bean.setUrlPatterns(Arrays.asList(\"/*\")); return bean; &#125;&#125; 整合MyBatis1.配置数据源使用druie数据源，配置如上 2.创建数据表3.创建实体类4.创建mapper在查询方法加注解：@Mapper 或者在主配置类或启动类加：@MapperScan(value = “com.zmy.mapper”) 自定义MyBatis配置规则配置文件 12345678910#开启驼峰命名mybatis: configuration: map-underscore-to-camel-case: false#添加mapper映射和mybatis的配置文件mybatis: configuration: map-underscore-to-camel-case: false config-location: 指定全局配置文件位置 mapper-locations: 指定mapper映射位置 12345678910111213//开启驼峰命名@Configurationpublic class MyBatisConfig &#123;@Bean public ConfigurationCustomizer configurationCustomizer()&#123; return new ConfigurationCustomizer() &#123; @Override public void customize(org.apache.ibatis.session.Configuration configuration) &#123; configuration.setMapUnderscoreToCamelCase(true); &#125; &#125;; &#125;&#125; 整合JPA编写实体类 123456789101112@Entity //这是一个实体类@Table(name = \"tbl_user\") //对应表名@JsonIgnoreProperties(value = &#123;\"hibernateLazyInitializer\"&#125;) //报500加这个public class User &#123; @Id //这是一个主键 @GeneratedValue(strategy = GenerationType.IDENTITY) //自增主键 private Integer id; @Column(name = \"last_name\",length = 50) //和数据表对应的一个列 private String lastNmae; @Column //省略，列明就是属性名 private String email; &#125; 编写dao 123//继承JpaRepositorypublic interface UserRepository extends JpaRepository&lt;User,Integer&gt; &#123;&#125; 配置文件 12345678910111213spring: datasource: url: jdbc:mysql://192.168.1.100:3306/jpa?serverTimeZone=GTM username: root password: '183786' driver-class-name: com.mysql.cj.jdbc.Driver #jpa配置 jpa: hibernate: #更新或创建数据表结构 ddl-auto: update #显示sql show-sql: true 十三、SpringBoot启动流程==（先跳过）==1.创建SpringApplication对象十四、自定义Starter 如何编写自动配置类 12345678910@Configuration //指定这个类是一个自动配置类@ConditionalOnXXX //在指定条件下生效@AutoConfigureAfter //指定自动配置类生效顺序@Bean //给容器添加组件@ConfigurationProperties(prefix = \"spring.mvc\") //结合WebMvcProperties类来绑定相关的配置@EnableConfigurationProperties(&#123; WebMvcProperties.class&#125;) //让WebMvcProperties生效加入到容器中自动配置类加载必须添加进MEAT-INF/spring.factories中 模式： 启动器只做依赖导入 专门编写一个自动配置模块 启动器依赖自动配置 自定义启动器名称 步骤： 创建一个空工程 编写一个zmy-spring-boot-starter模块，用来引入zmy-spring-boot-starter-autoconfigurer 编写一个配置类 12345678910111213141516171819202122//设置配置文件前缀@ConfigurationProperties(prefix = \"zmy.hello\")public class HelloProperties &#123; private String prefix; private String suffix; public String getPrefix() &#123; return prefix; &#125; public void setPrefix(String prefix) &#123; this.prefix = prefix; &#125; public String getSuffix() &#123; return suffix; &#125; public void setSuffix(String suffix) &#123; this.suffix = suffix; &#125;&#125; 编写一个可配置JavaBean 12345678910111213141516public class HelloService &#123; //引入配置程序 HelloProperties helloProperties; public HelloProperties getHelloProperties() &#123; return helloProperties; &#125; public void setHelloProperties(HelloProperties helloProperties) &#123; this.helloProperties = helloProperties; &#125; public String hello(String name)&#123; return helloProperties.getPrefix()+\"---\"+name+\"---\"+helloProperties.getSuffix(); &#125;&#125; 编写一个自动配置程序 12345678910111213141516//说明是一个配置类@Configuration//判断是不是web应用@ConditionalOnWebApplication//引入配置文件@EnableConfigurationProperties(HelloProperties.class)public class HelloServiceAutoConfiguration &#123; @Autowired HelloProperties helloProperties; @Bean public HelloService helloService()&#123; HelloService helloService = new HelloService(); helloService.setHelloProperties(helloProperties); return helloService; &#125;&#125; 创建META-INF/spring.factories，让SpringBoot识别 12org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\com.zmy.starter.HelloServiceAutoConfiguration","categories":[{"name":"Java","slug":"Java","permalink":"https://zmmmmy.github.io/categories/Java/"},{"name":"Spring","slug":"Java/Spring","permalink":"https://zmmmmy.github.io/categories/Java/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://zmmmmy.github.io/tags/Spring/"}]},{"title":"Hello","slug":"Hello","date":"2020-06-30T15:01:53.407Z","updated":"2020-07-02T16:59:11.664Z","comments":true,"path":"posts/f7d18982.html","link":"","permalink":"https://zmmmmy.github.io/posts/f7d18982","excerpt":"","text":"大家好，我是芝麻盐，这是一个乱七八糟的博客","categories":[{"name":"你好呀","slug":"你好呀","permalink":"https://zmmmmy.github.io/categories/%E4%BD%A0%E5%A5%BD%E5%91%80/"}],"tags":[]}],"categories":[{"name":"Java","slug":"Java","permalink":"https://zmmmmy.github.io/categories/Java/"},{"name":"Java8新特性","slug":"Java/Java8新特性","permalink":"https://zmmmmy.github.io/categories/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"},{"name":"Hexo","slug":"Hexo","permalink":"https://zmmmmy.github.io/categories/Hexo/"},{"name":"Git","slug":"Git","permalink":"https://zmmmmy.github.io/categories/Git/"},{"name":"Linux","slug":"Linux","permalink":"https://zmmmmy.github.io/categories/Linux/"},{"name":"Spring","slug":"Java/Spring","permalink":"https://zmmmmy.github.io/categories/Java/Spring/"},{"name":"你好呀","slug":"你好呀","permalink":"https://zmmmmy.github.io/categories/%E4%BD%A0%E5%A5%BD%E5%91%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zmmmmy.github.io/tags/Java/"},{"name":"Git","slug":"Git","permalink":"https://zmmmmy.github.io/tags/Git/"},{"name":"Linux","slug":"Linux","permalink":"https://zmmmmy.github.io/tags/Linux/"},{"name":"Spring","slug":"Spring","permalink":"https://zmmmmy.github.io/tags/Spring/"}]}